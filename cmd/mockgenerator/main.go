package main

import (
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"

	"github.com/dave/jennifer/jen"
)

// this function was deprecated.
func main() {
	services, serverMethods, err := getDataManagerList()
	if err != nil {
		log.Fatal(err)
	}

	// create struct
	createDMStruct()

	createMethods(serverMethods)

	createMockService(services)
}

func createDMStruct() {
	f := jen.NewFile("mock")
	// add header.
	f.HeaderComment(`Code generated by cmd\mockgenerator\main.go. Do NOT EDIT.`)
	// add import
	f.Type().Id("Mock").Struct(jen.List(jen.Qual("github.com/quocbang/api-server-basic/cmd/mockgenerator/setupmock", "Mock")))

	// create file
	file, err := os.Create("../../database/mock/mock_struct.go")
	if err != nil {
		log.Fatal(err)
	}

	_, err = file.WriteString(fmt.Sprintf("%#v", f))
	if err != nil {
		log.Fatal(err)
	}
}

type serviceMethodsRequest struct {
	serviceName string
	methods     []methodConfigs
}

type methodConfigs struct {
	Name   string
	Params string
	Return string
	Body   jen.Code
}

func createMethods(serviceMethods []serviceMethodsRequest) {
	for _, methods := range serviceMethods {
		f := jen.NewFile("mock")
		f.HeaderComment(`Code generated by cmd\mockgenerator\main.go. but you CAN EDIT your test case here.`)

		// import required package.
		f.Id("import").Defs(
			jen.Id(`"github.com/labstack/echo"`),
			jen.Id(`"github.com/quocbang/api-server-basic/impl/requests"`),
			jen.Id(`"gorm.io/gorm"`),
			jen.Id(`"github.com/go-redis/redis"`),
		)

		// create the struct definition.
		structDef := jen.Type().Id(fmt.Sprintf("mock%v", methods.serviceName)).Struct(
			jen.Id("db").Op("*").Qual("", "gorm.DB"),
		)
		f.Add(structDef)

		// create the constructor function.
		constructor := jen.Func().Id(fmt.Sprintf("new%vService", methods.serviceName)).Params(
			jen.Id("db").Op("*").Qual("", "gorm.DB"),
			jen.Id("redis").Op("*").Qual("", "redis.Client"),
		).Op("*").Id(fmt.Sprintf("mock%v", methods.serviceName)).Block(
			jen.Return(jen.Op("&").Id(fmt.Sprintf("mock%v", methods.serviceName)).Values(jen.Dict{
				jen.Id("db"): jen.Id("db"),
			})),
		)
		f.Add(constructor)

		// create methods.
		for _, mts := range methods.methods {
			f.Func().Params(
				jen.Id("m").Op("*").Id(fmt.Sprintf("mock%v", methods.serviceName)),
			).Id(mts.Name).Params(jen.Id(mts.Params)).Params(jen.Id(mts.Return)).Block(
				mts.Body,
			)
		}

		// create file
		file, err := os.Create(fmt.Sprintf("../../database/mock/mock_%v.go", methods.serviceName))
		if err != nil {
			log.Fatal(err)
		}
		defer file.Close()

		_, err = file.WriteString(fmt.Sprintf("%#v", f))
		if err != nil {
			log.Fatal(err)
		}
	}
}

func createMockService(services map[string]string) {
	f := jen.NewFile("mock")
	f.HeaderComment(`Code generated by cmd\mockgenerator\main.go. Do NOT EDIT.`)

	for serviceFunc, serviceInterface := range services {
		f.Func().Params(jen.Id("m").Op("*").Id("Mock")).Id(serviceFunc).Params().Qual("github.com/quocbang/api-server-basic/database", serviceInterface).Block(
			jen.Return(jen.Id(fmt.Sprintf("new%vService", serviceInterface)).Call(jen.Id("m").Dot("DB"), jen.Id("m").Dot("Redis"))),
		)
	}

	// create file
	file, err := os.Create("../../database/mock/mock_services.go")
	if err != nil {
		log.Fatal(err)
	}

	_, err = file.WriteString(fmt.Sprintf("%#v", f))
	if err != nil {
		log.Fatal(err)
	}
}

func getDataManagerList() (map[string]string, []serviceMethodsRequest, error) {
	data, err := os.ReadFile("../../database/dmlist.go")
	if err != nil {
		log.Fatal(err)
	}
	contents := string(data)

	if ok, err := regexp.MatchString("type .* interface {", contents); err != nil || !ok {
		if !ok {
			return nil, nil, fmt.Errorf("no service found")
		}
		log.Fatal(err)
	}

	lines := strings.Split(contents, "\n")
	services := make(map[string]string, len(lines)) // service function and service interface services[Users()] = Users
	for _, line := range lines {
		if strings.Contains(line, "()") {
			funcAndInterface := strings.Split(line, "() ")
			if len(funcAndInterface) == 2 {
				services[strings.TrimSpace(funcAndInterface[0])] = strings.TrimSpace(funcAndInterface[1])
			}
		}
	}

	methodLines := strings.Split(contents, "}\r")
	serviceMethods := []serviceMethodsRequest{}
	for _, line := range methodLines {
		for service := range services { // range all service example: Users, Tasks
			if strings.Contains(line, fmt.Sprintf("type %v interface {", service)) {
				interfaces := strings.Split(line, "\r\n")
				methodCfs := []methodConfigs{}
				for _, method := range interfaces { // multiple methods within interface
					if strings.Contains(method, "echo.Context") { // check whether is method.
						methodSplit := strings.Split(method, "(") // split method/request/reply
						methodCf := methodConfigs{}
						var re []string // return arg.
						for _, v := range methodSplit {
							// if after split contans both context and error => method like [Method(arg0, arg1) error]
							if strings.Contains(v, "echo.Context") && strings.Contains(v, "error") {
								values := strings.Split(v, ") ")
								for _, v2 := range values {
									comma := ""
									if v := strings.Split(v2, ","); len(v) > 1 {
										// request
										for idx, v3 := range v {
											if idx > 0 {
												comma = ","
											}
											methodCf = methodConfigs{
												Name:   methodCf.Name,
												Params: strings.TrimLeft(fmt.Sprintf("%v%v arg%v %v", methodCf.Params, comma, idx, v3), " "), // arg0 echo.Context, arg1 CreateTaskRequest
											}
										}
									} else {
										// reply and switch case body.
										methodCf = methodConfigs{
											Name:   methodCf.Name,
											Params: methodCf.Params,
											Return: strings.TrimLeft(fmt.Sprintf("%v%v %v", methodCf.Return, comma, v2), " "), // CreateTaskReply, error
										}
									}
								}
							} else if values := strings.Split(v, ", "); len(values) < 2 { // method return with more than 1 args.
								// only method ID => CreateTasks.
								methodCf = methodConfigs{
									Name: strings.Trim(values[0], "\t"),
								}
							} else {
								// method paramater => (arg0, arg1) (return0, return1).
								for i, v2 := range values {
									cleanString := strings.Trim(v2, ") ") // requests.CreateTaskRequest) => requests.CreateTaskRequest
									// if strings.Contains(v2, "requests") {
									// 	trimRequest := strings.Split(cleanString, ".")
									// 	if len(trimRequest) > 1 {
									// 		cleanString = trimRequest[1] // requests.CreateTaskRequest => CreateTaskRequest
									// 	}
									// }
									comma := ""
									if i > 0 {
										comma = ","
									}
									if strings.Contains(v, "echo.Context") { // should is request
										methodCf = methodConfigs{
											Name:   methodCf.Name,
											Params: strings.TrimLeft(fmt.Sprintf("%v%v arg%d %v", methodCf.Params, comma, i, cleanString), " "), // arg0 echo.Context, arg1 CreateTaskRequest
										}
									} else { // reply
										// set return arg.
										re = append(re, cleanString)
										methodCf = methodConfigs{
											Name:   methodCf.Name,
											Params: methodCf.Params,
											Return: strings.TrimLeft(fmt.Sprintf("%v%v %v", methodCf.Return, comma, cleanString), " "), // CreateTaskReply, error
										}
									}
								}
							}
						}
						jenRet := jen.Return()
						if len(re) < 2 {
							jenRet.Add(jen.Nil())
						} else {
							for _, v := range re {
								if v == "error" {
									jenRet.Add(jen.Nil())
								} else {
									jenRet.Add(jen.Id(v).Block()).Op(",")
								}
							}
						}
						// complete each method.
						methodCf = methodConfigs{
							Name:   methodCf.Name,
							Params: methodCf.Params,
							Return: methodCf.Return,
							Body: jen.Switch().Block(
								jen.Default().Block(
									jenRet,
								),
							),
						}
						methodCfs = append(methodCfs, methodCf)
					}
				}

				serviceMethods = append(serviceMethods, serviceMethodsRequest{
					serviceName: service,
					methods:     methodCfs,
				})
			}
		}
	}

	return services, serviceMethods, nil
}
